{
    "jobName": "transcript-job-audio-assistant",
    "accountId": "337909742319",
    "status": "COMPLETED",
    "results": {
        "transcripts": [
            {
                "transcript": "Hi, everybody and welcome to a new video in the audio signal processing for machine learning series. This time we'll implement the amplitude envelope feature from scratch. And in the process, we'll also get familiar with Libros, which is the audio processing library that we'll use throughout this course. And we also plot waveforms and the amplitude envelope itself. Before getting, I wanted to show you the Libres documentation here. So you can check this out. I'll leave you the link in the description below. Interesting thing is that Libres doesn't have an extractor for amplitude envelope and so we'll build one from scratch. OK. So now let's get started. And so the first thing that we want to do is to, yeah, let's start by importing uh Li Broza. And we want to also import Li Brusa dot display that has utilities for plots for plotting stuff. OK. So now what we want to do is to load audio files. OK? And so what audio files are we using today? Well, I have here in the audio signal processing for machine learning uh code base here at uh in the folder eight, which is the one for this current video, have a sub folder called audio. Here we have three audio files. So one is called ABC and it's a 32nd passage of an orchestral piece by uh Claude the Bey. And we have 30 seconds by Duke Ellington, the jazz musician and 30 seconds from a song by the red hot chili pepper. So we have a little bit of rock, uh classical music and jazz music in there. OK. So now let's uh create uh let's um get the paths. So we'll have the Bey um we'll call this the Bey file and this I can get from audio and then over here BC W and then I can do the same thing for the red hot chili peppers. So I'll do audio and then I'll say red hot uh W and same thing for the Duke Ellington uh file audio and then I'll say uh Duke. OK, perfect. So these are the, the paths now I can do this because I started Jupiter a notebook uh in here. So at this level here, so basically I then can access uh the audio uh folder and then obviously the file itself. OK. So the first thing that we want to do here is to import from ipython display as IP D. And so this has this package has some interesting uh utilities that we can use to just like listen to some music here in a Jupiter no book. So lets take a look at this So we'll do IP D dot uh audio and then we'll pass in the, the BC file over here. And all of a sudden, we have our amazing uh audio player here. We can listen to uh like this music, but let's load the other music first. So we'll load a red dot file over here and then we load the Duke Ellington five. OK. So let's listen to this music. OK. So this is a, an orchestral piece by Claude Du Bei. So loads of strings here and as you will see there is a climax here, the intensity rises up and then it just fades away. OK. Nice. So, OK, you get the idea and then we have some music by Duke Ellington. Very bouncy. Jazzy. OK? Cool. So you have the, an idea of what we are dealing with in terms of like music or like audio cues over here. OK. So now we actually want to load these wave files using a libros. And for doing that, we can use a method, basic method uh from Li Brosa that's called load, not surprisingly. OK. So um here this method gives us back uh the signal itself which in this case, we'll call just like the BC and then it gives us back the sample rate. And so we'll do a libres dot load and then we here we should pass the, the file. OK? So now there are a few uh a bunch actually of parameters optional parameters that we have. One is for example, sample rate, we could uh specify a sample rate that we want uh Libres to load our uh audio file uh with. And the, the basic uh case that we have here or I mean the default value that Li Brosa uses is 22,050 which is a totally fine sampling rate for uh like our needs. And so I'm not going to change that. And then we have also like another option which is called mono, which is a ball parameter. So this mono could be equal to true or false and basically deals tells Liberator of whether we want to load the audio file as as is, for example, it could be a stereo file. So with two channels or like as man, the default behavior of load is to uh load the audio file as mono. And this is like totally fine and we usually work with mo mono signals because we, you really don't lose that much information when you are dealing uh like with mono a audio compared to like uh yeah, stereo audio. For example, obviously, this can change from problem to problem. But uh for today, we're just gonna use the default or MO OK. So now let's uh load also the uh red hot. And here I use the underscore because we'll have like the sample ridge here and it's gonna be the same. So we don't want, we don't care about that variable now. OK. So here this, the BC file becomes the uh red hot file and then we'll do a duke and we'll do once again Li Brosa dot uh load and here we'll pass in the uh duke file. Ok. Good. OK. So now we've loaded all of these guys for timing. I'll just be working with the BC, one of these to show you like a few like things about like what we've loaded. But then when I want to compare this, obviously, I use all of these three different signals. If you're wondering how many samples we have in the uh signal. So we can just do ABC dot size. And you'll see that we have this many samples, almost 700,000 samples. OK? So now let's take a look at the uh duration of one sample. OK? So this uh du Samp let's call this sample duration and this is equal to the inverse of the sampling range. And let's print this so that it's nicer to see and we'll say that um duration of one sample is and here we pass in the sample duration. And then we want to specify that we only want six decimal values and this is in seconds. OK? So let's take a look at this. And so the duration of one sample is 0.0000 45 seconds. So this is like a very, very short duration. So now why do we want this sample duration. Well, because I want to uh calculate the uh duration of the audio signal in seconds. Ok. And so for that, we should do a duration and here we should do duration is equal to the sample duration. So the duration for one sample and multiply that by the total number of samples that we have in the signal, right? And let me grab this. So the duration of signal is and he will pass in the duration. Oh, I had a type over here. OK? And the duration of the signal as expected is 30 seconds. So this is the length of the uh audio files that we are dealing with right now. OK. So let me just take out a few of this boxes here because otherwise a little bit too cluttered the whole thing. OK? So now we know the duration of the signal. So what, what, what I want to do really here is just like to visualize the waveforms. OK. So how do we do that? Well, given we want to do something a little bit elaborate, I want to import uh much uh plot of leap dot plot PLT. OK. So yeah, I have another type in here. OK. So we'll create a figure and so we'll do plot dot uh figure and we'll pass in a parameter called thick size and this is uh gonna be equal. Yeah, we'll put 15 for the width and 17 for the height. And now we're gonna have three different subplots. And we want to stack the waveforms for all the different audio signals uh vertically. OK. So we'll do a plots dot soup plots. And here we'll say that we want uh three rows, one column and this plot is at index uh one. And so here we'll do a uh so here, what we can do is do a uh li browser dot display and we'll do a wave plots. OK? And so here we need to pass the uh signal and the signal in this case is the BC. So we'll have the BC first, then we'll do a plot dot uh title and the title in this case is gonna be uh the BC and given, I know that this mm waveforms are gonna be normalized between minus one and one. I want to set a range on the um uh on the uh Y axis and I'll set that to uh should be minus one and one. OK. So we repeat this a couple of times, but now this is gonna be for uh red hot. And so we'll call this red chili peppers and then we'll do the same thing for uh Duke Ellington and we'll call this Du uh Duke Ellington, ok. And finally, here we'll do a plot dot show. Now, let's take a look at this. If I haven't messed up, we should see the results. And indeed, I've messed up a little bit. Uh So here you have like all of the uh different um wave plots uh like all in the same uh uh graph, right? OK. So we want to change that and, and that's why we had this subplot. So here we put this at index two and here at index three. Also another thing that I want to do is add a little bit of transparency here because it's gonna just like look nicer. So in this web plot, so we'll do this, do this. OK? Let's go. Let's see. OK. Here we go. OK. So here we have the different wave plots for the beauty, the red hot chili peppers song and Duke Ellington's piece. OK. So we can draw conclusions like already like by comparing these guys here. So as you can see over all the uh the BC wave plot is kind of like is very fluid in its uh like envelope, right? So it is like fairly like stable down here. Then you have like a huge rise of tension and, and, and rise of energy right over here. Here you have the climax and then it goes back down. If we compare that with the red hot chili pepper song, it's quite different, right? Because here the the overall envelope tends to remain the same, right? And that's a feature that you'll always, you'll often find in popular music. And here we can talk about like rock music, pop music or EDM for example. And here you'll notice also certain spikes in uh the uh waveform and these spikes as you can see are like at regular points in time. And as you guess it, these are like the kick snare. Uh So the drum k like coming in, right? And uh if we compare this, like with uh Duke Ellington, you have like a little bit like of the two worlds here, right? And the classical music and the the rock music. So there's quite a lot of variability like in, in intensity, but it's more like micro is not like at the macro level. And so, so basically, the point, the takeaway point here is that when you're dealing with uh classical music, which uses uh obviously a lot of like acoustic, mainly acoustic instruments, then you'll have like a lot of variability in the waveform. Whereas like with popular music, which more kind of like electronic electric uh uh instruments then like the, the waveform tends to be a little bit like more stable, obviously, like this can change a lot depending on the song. But like this is like a general rule of thumb. OK. So now the next step that we want to do is to actually calculate the amplitude envelope. OK. And so I'm gonna create a function for doing that. Actually, I'm gonna create two functions. So one like is gonna be like a little bit easier to understand in some sort of like Python code the other one is a little bit fancier but the algorithm is the same. The only thing that changes is the, the, the Python code. OK. So let's start with the, with the simple one, the most uh the more intuitive the amplitude envelope. And here we sh uh this uh function takes the uh a signal and it takes a frame size. OK. So uh amplitude envelope and we're gonna set this equal to a list. If you guys remember from the previous video uh the for calculating the amplitude envelope at a specific frame, what we want to do is just like take the maximum value of the amplitude calculated across all the samples in that given frame. And for getting the amplitude envelope for the whole signal, we take the uh the max uh amplitude for uh each frame. And yeah, we just like uh a pen that like to get like a value for each uh frame right now. If you don't remember that I went into quite details about like the mathematics of the amplitude envelope in the previous video. So you should definitely check that out and it should be over here just like go check that out. OK. So here we want to calculate, calculate the amplitude envelope for each frame. So, and for doing that, we'll do a four uh I in range and here we'll start from zero, then we'll stop at the length of the signal. But here we don't want to just uh have this eye that goes like 123 at each iteration. No, we wanted to jump and we wanted to jump by the, the frame size. So like this third uh like argument here in the range function is the step size in this case. So let's assume the frame size is equal to 100. So we'll start at the first iteration I is going to be equal to zero, then it's going to be second iteration is going to be equal to 100 then 203 100 you get the idea why do we do that? Well, we do that because in this way, I is always going to be the first sample in a frame. OK? And that's something that we definitely need. And so now we could say current frame unplayed ch envelope and they look and so this is equal to the max of the slice of signal that just considers the all the frames in the current, uh all the samples in the current frame. And so this is given by uh the slice of signal calculated between I and I plus frame size. OK. So we are slicing the signal considering only the samples uh for a given frame. OK. So, and here we take the um amplitude envelope and we want to append the current frame amplitude envelope. OK. So we'll do this and here we can uh return the amplitude envelope but we'll return that as a N pi array. So we'll do this. OK. So this should work. But uh let me just create a constant up here. So we'll put the frame size equal to 1000 and 24 which is totally legit number for frame size. OK. So now let's try to calculate the amplitude envelope for the BC signal. And so we'll do a um pude envelope, we'll pass in the BC signal and we'll pass in the frame size. Now, what I want to do is show you the length of this guy. And obviously, we have an error here, which is NP because I didn't import NP. And so let me import that. So we'll do import NPI as MP. OK? Now let's go back down here and hopefully this should work. OK? Here we go. So here we have uh the, the size of this array is 646. So this is the number of frames that we have in the, the BC uh signal. Now, if I change the frame size, uh let's say I have it. So I put it at 512. So now the number of frames should like double or the number of uh like uh um the, the, the size of the ali envelope also should double, right. Let's see. Yeah, but I should rerun this and here we go. So we have double the uh the number of frames over here. OK? Now, this is all good and well, but it only consider the, the case, this amplitude envelope function where we have uh non overlapping frames. If we had uh overlapping uh frames, we would have, we would need to uh change like this um function. And now if you don't remember what like overlapping and non overlapping frames are, I suggest you to go check out this video to just like refresh or like learn that. But basically, when we have over uh overlapping frames, we'll still have like the, the frame size, which in this case will put equal to 1000 24. But then we have another um important like parameter that's called the hop length that tells us. So given like the current frame, how many sample samples we shift to the right for calculating the next frame. And in this case, we'll put 512 which again is a totally legit uh H length. And here we want to change this function so that it accepts also the a new parameter called hop length. So how do we change this? Well, what the only thing that we need to change here is that instead of like jumping at each iteration by the frame size, we want to jump by the uh hop length, right? So if we, if we change that now we should have like the whole thing working. OK. So let's retry this. OK. So here I'll have to pass the H length, I'll do that And as you can see here, we have 1000 292 samples over here and which uh which is expected because we have a H length of 512 which is like the same like jumping to the right at each frame that we used before when we had the frame size at 512. There's also a nicer way to calculate the amplitude envelope. I mean, the algorithm is the same. It's just like the, the Python code that's a little bit fancier. And I guess they, which showed up to you. OK. So let's call this fancy Ted envelope and we'll pass in the very same uh parameters over here. And this is gonna be just a one liner. So we'll do a NP array and here we'll have a list of comprehension and here we'll take the maximum of the signal. Uh Once again, this is gonna be between I and I plus hop uh length. And then we'll take this for I in uh well, this is not H length, this is frame size and then we'll take the four I in uh range. And here is gonna be between zero of the signal dot size and the step that we'll use. Now this is the hop length once again uh up length. OK? So, yep, this should work. OK? So now let me calculate. Uh yeah, let's put it down here. So we'll do fancy, we'll call this Fancy amplitude envelope for the BC. And we'll do a fancy oops fancy amplitude envelope and we pass in these parameters. OK. Here we go attempts to work fine. Now, what we want to show is that the uh the amplitude envelope calculated with this function, the amplitude envelope function with the fancy amplitude envelope function are the same. So if we're doing that, we could do I A A E amplitude envelope. Well, let's do this. We'll do a EW PC is equal to fancy a amplitude envelope to PC for all the values. So let's see if this works. OK. Yeah, that's true. So basically what I've done here is compare uh like all the items in the array, one by one with the current sponge like item in the other array. And then I, I want like I wanted to have like that all of these values must be equal for all of them. And if that's the case, then we would get a tree which is like what we got. And so basically the two values are the same. In other words, we wrote like the same algorithms like in, in two different versions with Python code. OK. So this is nice. Now, the final thing that I want to do is to visualize, I want to visualize the ample envelope for uh all the audio files. OK. So how do we do that? Well, it's quite simple and, and it really relies on the, the code that we've already uh written over here for like visualizing like the, the, the wave form. So now the only difference here that we need is to add another plot uh like in each of these like subplots. And so we'll do a plot dot PLT dot uh plot. Here, we'll do T and here we'll pass the A, the BC and then the color is gonna be equal to red. Now, if you're wondering about this, t uh we haven't defined it and that yet. And so I'll define that in a second. But before doing that, I just want to repeat this down here for uh red hots and down here for Duke Ellington. Oh, let's take this. OK. Now, as you know, as you probably noticed, I haven't defined the amplitude envelope for the red hots yet. And so we'll do that. We're here and so here I'll do a amplitude envelope and here I'll pass uh red, the red hot uh signal and then the frame size and H length and I'll do the same for Duke Ellington. Yeah, let me just grab this and pass in here, Duke. OK. This should work. Now, the one thing that it's still missing here that I said is the, this key, right? OK. So this is basically like the X axis for the plot. And here we have like the Y axis. So, and here we, we want uh time and so for doing that, what we need to do is first of all get the frames and the frames is gonna be uh equal to a range between a zero and uh the size of the amplitude envelope. And so this is equal to a WC dot size I could have used also a amplitude envelope uh for like Duke Ellington or red hot chili peppers because it's like the same in terms of like the its length its size. OK. So now I want to calculate tea and here for passing from frames to time, we can use a, a very nice uh function by lib browser and it's called frames to time over here. And so here we need to specify the frames and uh we uh need to also specify the, the hop length and the hop length in this case is equal to hop length over here. OK? So here we've basically got the, the time and uh along with the time we, we've also we also plot the amplitude envelope for um each of the different audio files. OK? So if I haven't made any mistakes, so this should work. Let's see. And here it goes and we have it in red and yeah, not surprisingly, the amplitude envelope just like full is like the the envelope like of the wave firm. And you can see it here like in red for the BC, for the red hot chili pepper song and for uh Duke Ellington. OK? So now one thing like that's uh obvious once again, is that like, they usually uh you have like this spikes like in rock music or like popular music more in general, which uh are determined by like the drum kit, like kicking in. And then, uh usually you also have like the amplitude envelope, the mean amplitude envelope for music that's in a rock genre, pop, popular genre that's usually higher than that for like classical music or jazz music. OK? But here you have it. I hope like you've enjoyed this video. Now, you know how to create uh a, how to calculate the amplitude envelope, how to visualize waveforms the amplitude envelope and play around with like basic processing features in the browser. So that's all for today. So if you like the video, please consider like living alike. If you haven't subscribed yet, please consider subscribing if you have any questions, leave them in the comment section below and I guess I'll see you next time. Cheers."
            }
        ],
        "audio_segments": [
            {
                "id": 0,
                "transcript": "Hi, everybody and welcome to a new video in the audio signal processing for machine learning series. This time we'll implement the amplitude envelope feature from scratch. And in the process, we'll also get familiar with Libros, which is the audio processing library that we'll use throughout this course. And we also plot waveforms and the amplitude envelope itself. Before getting,",
                "start_time": "0.0",
                "end_time": "26.219"
            },
            {
                "id": 1,
                "transcript": "I wanted to show you the Libres documentation here. So you can check this out. I'll leave you the link in the description below. Interesting thing is that Libres doesn't have an extractor for amplitude envelope and so we'll build one from scratch. OK. So now let's get started. And so the first thing that we want to do is to, yeah, let's start by importing uh Li Broza.",
                "start_time": "26.229",
                "end_time": "52.459"
            },
            {
                "id": 2,
                "transcript": "And we want to also import Li Brusa dot display that has utilities for plots for plotting stuff. OK. So now what we want to do is to load",
                "start_time": "52.74",
                "end_time": "68.3"
            },
            {
                "id": 3,
                "transcript": "audio files.",
                "start_time": "68.94",
                "end_time": "70.22"
            },
            {
                "id": 4,
                "transcript": "OK? And so what audio files are we using today? Well, I have here in the audio signal processing for machine learning uh code base here at uh in the folder eight, which is the one for this current video, have a sub folder called audio. Here we have three audio files. So one is called ABC and it's a 32nd passage of an orchestral piece by",
                "start_time": "70.51",
                "end_time": "99.15"
            },
            {
                "id": 5,
                "transcript": "uh Claude the Bey. And we have 30 seconds by Duke Ellington, the jazz musician and 30 seconds from a song by the red hot chili pepper. So we have a little bit of rock, uh classical music and jazz music in there. OK. So now let's uh create uh let's um get the paths. So we'll have the Bey um we'll call this the Bey file and",
                "start_time": "99.319",
                "end_time": "126.9"
            },
            {
                "id": 6,
                "transcript": "this I can get from audio and then over here",
                "start_time": "127.62",
                "end_time": "133.449"
            },
            {
                "id": 7,
                "transcript": "BC W and then I can do the same thing for the red hot chili peppers. So I'll do audio and then I'll say red hot uh W and same thing for the Duke Ellington uh file audio and then I'll say uh Duke.",
                "start_time": "135.63",
                "end_time": "159.8"
            },
            {
                "id": 8,
                "transcript": "OK, perfect. So these are the, the paths now I can do this because I started Jupiter a notebook uh in",
                "start_time": "160.21",
                "end_time": "170.86"
            },
            {
                "id": 9,
                "transcript": "here. So at this level here, so basically I then can access uh the audio uh folder and then obviously the file itself. OK. So the first thing that we want to do here is to import",
                "start_time": "171.869",
                "end_time": "188.83"
            },
            {
                "id": 10,
                "transcript": "from ipython display",
                "start_time": "190.94",
                "end_time": "195.809"
            },
            {
                "id": 11,
                "transcript": "as IP D. And so this has this package has some interesting uh utilities that we can use to just like listen to some music here in a Jupiter no book. So lets take a look at this So we'll do IP D dot uh audio and then we'll pass in the, the BC file over here. And all of a sudden, we have our amazing",
                "start_time": "197.25",
                "end_time": "225.69"
            },
            {
                "id": 12,
                "transcript": "uh audio player here. We can listen to uh like this music, but let's load the other music first. So we'll load a red dot file over here",
                "start_time": "226.27",
                "end_time": "238.91"
            },
            {
                "id": 13,
                "transcript": "and then we load the",
                "start_time": "239.5",
                "end_time": "242.5"
            },
            {
                "id": 14,
                "transcript": "Duke Ellington five. OK. So let's listen to this music.",
                "start_time": "244.339",
                "end_time": "247.649"
            },
            {
                "id": 15,
                "transcript": "OK. So this is a, an orchestral piece by Claude Du Bei.",
                "start_time": "253.41",
                "end_time": "257.92"
            },
            {
                "id": 16,
                "transcript": "So loads of strings here and as you will see there is a climax here, the intensity rises up",
                "start_time": "258.869",
                "end_time": "267.38"
            },
            {
                "id": 17,
                "transcript": "and then it just fades away.",
                "start_time": "268.019",
                "end_time": "271.25"
            },
            {
                "id": 18,
                "transcript": "OK.",
                "start_time": "274.279",
                "end_time": "274.869"
            },
            {
                "id": 19,
                "transcript": "Nice. So,",
                "start_time": "275.64",
                "end_time": "277.429"
            },
            {
                "id": 20,
                "transcript": "OK, you get the idea and then we have some music by Duke Ellington. Very bouncy. Jazzy.",
                "start_time": "290.63",
                "end_time": "298.279"
            },
            {
                "id": 21,
                "transcript": "OK? Cool. So you have the, an idea of what we are dealing with in terms of like music or like audio cues over here. OK. So now we actually want to load these wave files using a libros. And for doing that, we can use a method, basic method uh from Li Brosa that's called load, not surprisingly. OK. So",
                "start_time": "304.119",
                "end_time": "329.649"
            },
            {
                "id": 22,
                "transcript": "um here this method gives us back uh the signal itself which in this case, we'll call just like the BC and then it gives us back the sample rate. And so we'll do a libres dot load and then we here we should pass the, the file. OK?",
                "start_time": "330.119",
                "end_time": "352.549"
            },
            {
                "id": 23,
                "transcript": "So now there are a few uh a bunch actually of parameters optional parameters that we have. One is for example, sample rate, we could uh specify a sample rate that we want uh Libres to load our uh audio file uh with.",
                "start_time": "352.72",
                "end_time": "370.22"
            },
            {
                "id": 24,
                "transcript": "And the, the basic uh case that we have here or I mean the default value that Li Brosa uses is 22,050 which is a totally fine sampling rate for uh like our needs. And so I'm not going to change that. And then we have also like another option which is called mono, which is a ball parameter. So this mono could be equal to true or false and basically deals tells Liberator of whether we want to load the",
                "start_time": "370.45",
                "end_time": "399.179"
            },
            {
                "id": 25,
                "transcript": "audio file as as is, for example, it could be a stereo file. So with two channels or like as man, the default behavior of load is to uh load the audio file as mono. And this is like totally fine and we usually work with mo mono signals because we, you really don't lose that much information when you are dealing uh like with mono a audio compared to like uh yeah, stereo audio. For example,",
                "start_time": "399.19",
                "end_time": "427.929"
            },
            {
                "id": 26,
                "transcript": "obviously, this can change from problem to problem. But uh for today, we're just gonna use the default or MO OK. So now let's uh load also the uh red hot. And here I use the underscore because we'll have like the sample ridge here and it's gonna be the same. So we don't want, we don't care about that variable now. OK.",
                "start_time": "428.2",
                "end_time": "451.179"
            },
            {
                "id": 27,
                "transcript": "So here this, the BC file becomes the uh red hot file and then we'll do a duke and we'll do once again Li Brosa dot uh load and here we'll pass in the uh duke file. Ok.",
                "start_time": "451.44",
                "end_time": "472.679"
            },
            {
                "id": 28,
                "transcript": "Good. OK. So now we've loaded all of these guys for timing. I'll just be working with the BC, one of these to show you like a few like things about like what we've loaded. But then when I want to compare this, obviously, I use all of these three different signals.",
                "start_time": "473.57",
                "end_time": "489.609"
            },
            {
                "id": 29,
                "transcript": "If you're wondering how many samples we have in the uh signal. So we can just do ABC dot size. And you'll see that we have this many samples, almost 700,000 samples. OK? So now let's take a look at the uh duration of one sample.",
                "start_time": "489.619",
                "end_time": "515.34"
            },
            {
                "id": 30,
                "transcript": "OK? So this uh du Samp let's call this sample duration and this is equal to the inverse of the sampling range. And let's print this so that it's nicer to see and we'll say that um duration of one sample is and here we pass in the sample duration.",
                "start_time": "515.69",
                "end_time": "543.84"
            },
            {
                "id": 31,
                "transcript": "And then we want to specify that we only want six decimal values and this is in seconds. OK? So let's take a look at this. And so the duration of one sample is 0.0000 45 seconds. So this is like a very, very short duration.",
                "start_time": "544.07",
                "end_time": "564.289"
            },
            {
                "id": 32,
                "transcript": "So now why do we want this sample duration. Well, because I want to uh calculate the uh duration of the audio signal",
                "start_time": "564.469",
                "end_time": "575.28"
            },
            {
                "id": 33,
                "transcript": "in seconds. Ok. And so for that, we should do a duration",
                "start_time": "576.01",
                "end_time": "584.52"
            },
            {
                "id": 34,
                "transcript": "and here we should do duration is equal to the sample duration. So the duration for one sample and multiply that by the total number of samples that we have in",
                "start_time": "585.359",
                "end_time": "602.46"
            },
            {
                "id": 35,
                "transcript": "the signal, right?",
                "start_time": "604.059",
                "end_time": "605.409"
            },
            {
                "id": 36,
                "transcript": "And let me grab this. So the duration of signal",
                "start_time": "606.34",
                "end_time": "614.4"
            },
            {
                "id": 37,
                "transcript": "is and he will pass in the duration.",
                "start_time": "615.78",
                "end_time": "621.15"
            },
            {
                "id": 38,
                "transcript": "Oh, I had a type over here. OK?",
                "start_time": "623.809",
                "end_time": "627.429"
            },
            {
                "id": 39,
                "transcript": "And the duration of the signal as expected is 30 seconds. So this is the length of the uh audio files that we are dealing with right now. OK. So let me just take out a few of this",
                "start_time": "628.39",
                "end_time": "641.039"
            },
            {
                "id": 40,
                "transcript": "boxes here because otherwise a little bit too cluttered the whole thing. OK? So now we know the duration of the signal. So what, what, what I want to do really here is just like to visualize the waveforms. OK. So how do we do that? Well, given we want to do something a little bit elaborate, I want to import uh much uh plot of leap",
                "start_time": "641.57",
                "end_time": "670.58"
            },
            {
                "id": 41,
                "transcript": "dot plot PLT. OK. So",
                "start_time": "670.859",
                "end_time": "676.609"
            },
            {
                "id": 42,
                "transcript": "yeah, I have another type in here. OK. So we'll create a figure and so we'll do plot dot uh figure and we'll pass in a parameter called thick size and this is uh gonna be equal. Yeah, we'll put 15 for the width and 17 for the height.",
                "start_time": "677.479",
                "end_time": "698.76"
            },
            {
                "id": 43,
                "transcript": "And now we're gonna have three different subplots. And we want to stack the waveforms for all the different audio signals uh vertically. OK. So we'll do a plots dot soup plots. And here we'll say that we want uh three rows, one column and this plot is at index uh one.",
                "start_time": "699.179",
                "end_time": "722.14"
            },
            {
                "id": 44,
                "transcript": "And so here we'll do a uh so here, what we can do is do a uh li browser dot display and we'll do a wave plots. OK? And so here we need to pass the uh signal",
                "start_time": "722.95",
                "end_time": "743.13"
            },
            {
                "id": 45,
                "transcript": "and the signal in this case is the BC. So we'll have the BC first, then we'll do a plot dot uh title and the title in this case is gonna be uh the BC and given, I know that this mm waveforms are gonna be normalized between minus one and one. I want to set a range on the um",
                "start_time": "743.39",
                "end_time": "768.429"
            },
            {
                "id": 46,
                "transcript": "uh on the uh Y axis and I'll set that to",
                "start_time": "769.409",
                "end_time": "775.369"
            },
            {
                "id": 47,
                "transcript": "uh should be minus one and one. OK.",
                "start_time": "777.71",
                "end_time": "783.469"
            },
            {
                "id": 48,
                "transcript": "So we repeat this a couple of times, but now this is gonna be for",
                "start_time": "784.719",
                "end_time": "793.7"
            },
            {
                "id": 49,
                "transcript": "uh red hot. And so we'll call this red chili peppers",
                "start_time": "795.08",
                "end_time": "801.789"
            },
            {
                "id": 50,
                "transcript": "and then we'll do the same thing for uh Duke Ellington and we'll call this Du uh Duke Ellington, ok. And finally, here we'll do a plot dot show.",
                "start_time": "802.469",
                "end_time": "817.75"
            },
            {
                "id": 51,
                "transcript": "Now, let's take a look at this. If I haven't messed up, we should see the results. And indeed, I've messed up a little bit. Uh So here you have like all of the uh different um wave plots uh like all in the same uh uh graph,",
                "start_time": "817.929",
                "end_time": "836.145"
            },
            {
                "id": 52,
                "transcript": "right? OK. So we want to change that and, and that's why we had this subplot. So here we put this at index two and here at index three. Also another thing that I want to do is add a little bit of transparency here because it's gonna just like look nicer. So in this web plot, so we'll do this,",
                "start_time": "836.155",
                "end_time": "858.21"
            },
            {
                "id": 53,
                "transcript": "do this. OK? Let's go. Let's see. OK. Here we go. OK. So here we have the different wave plots for the beauty, the red hot chili peppers song and Duke Ellington's piece. OK. So we can draw conclusions like already like by comparing these guys here. So as you can see over all the uh the BC wave plot",
                "start_time": "859.479",
                "end_time": "883.33"
            },
            {
                "id": 54,
                "transcript": "is kind of like is very fluid in its uh like envelope, right? So it is like fairly like stable down here. Then you have like a huge rise of tension and, and, and rise of energy right over here. Here you have the climax and then it goes back down.",
                "start_time": "883.34",
                "end_time": "903.27"
            },
            {
                "id": 55,
                "transcript": "If we compare that with the red hot chili pepper song, it's quite different, right? Because here the the overall envelope tends to remain the same, right? And that's a feature that you'll always, you'll often find in popular music. And here we can talk about like rock music, pop music or EDM for example. And",
                "start_time": "903.5",
                "end_time": "925.559"
            },
            {
                "id": 56,
                "transcript": "here you'll notice also certain spikes in uh the uh waveform and these spikes as you can see are like at regular points in time. And as you guess it, these are like the kick snare. Uh So the drum k like coming in, right?",
                "start_time": "925.77",
                "end_time": "942.34"
            },
            {
                "id": 57,
                "transcript": "And uh if we compare this, like with uh Duke Ellington, you have like a little bit like of the two worlds here, right? And the classical music and the the rock music. So there's quite a lot of variability like in, in intensity, but it's more like micro is not like at the macro level.",
                "start_time": "942.539",
                "end_time": "961.479"
            },
            {
                "id": 58,
                "transcript": "And so, so basically, the point, the takeaway point here is that when you're dealing with uh classical music, which uses uh obviously a lot of like acoustic, mainly acoustic instruments, then you'll have like a lot of variability in the waveform. Whereas",
                "start_time": "961.669",
                "end_time": "978.489"
            },
            {
                "id": 59,
                "transcript": "like with popular music, which more kind of like electronic electric uh uh instruments then like the, the waveform tends to be a little bit like more stable, obviously, like this can change a lot depending on the song. But like this is like a general rule of thumb. OK. So now the next step that we want to do is to actually calculate the",
                "start_time": "978.5",
                "end_time": "1000.929"
            },
            {
                "id": 60,
                "transcript": "amplitude",
                "start_time": "1001.849",
                "end_time": "1003.219"
            },
            {
                "id": 61,
                "transcript": "envelope. OK. And so I'm gonna create a function for doing that. Actually, I'm gonna create two functions. So one like is gonna be like a little bit easier to understand in some sort of like Python code the other one is a little bit fancier but the algorithm is the same. The only thing that changes is the, the, the Python code. OK. So let's start with the, with the simple one, the most uh the more intuitive the amplitude envelope.",
                "start_time": "1004.099",
                "end_time": "1032.859"
            },
            {
                "id": 62,
                "transcript": "And here we sh uh this uh function takes the uh a signal and it takes a frame size. OK.",
                "start_time": "1033.75",
                "end_time": "1044.17"
            },
            {
                "id": 63,
                "transcript": "So",
                "start_time": "1045.3",
                "end_time": "1046.099"
            },
            {
                "id": 64,
                "transcript": "uh amplitude envelope and we're gonna set this equal to a list. If you guys remember from the previous video uh the for calculating the amplitude envelope at a specific frame, what we want to do is just like take the maximum value of the amplitude calculated across all the samples in that given frame. And for getting the amplitude envelope for the whole",
                "start_time": "1046.93",
                "end_time": "1075.51"
            },
            {
                "id": 65,
                "transcript": "signal, we take the uh the max uh amplitude for uh each frame. And yeah, we just like uh a pen that like to get like a value for each uh frame right now. If you don't remember that I went into quite details about like the mathematics of the amplitude envelope in the previous video. So you should definitely check that out and it should be over here just like go check that out. OK. So",
                "start_time": "1075.52",
                "end_time": "1105.41"
            },
            {
                "id": 66,
                "transcript": "here we want to calculate, calculate the amplitude envelope for each frame. So, and for doing that, we'll do a four",
                "start_time": "1105.709",
                "end_time": "1120.04"
            },
            {
                "id": 67,
                "transcript": "uh I in range",
                "start_time": "1120.579",
                "end_time": "1124.25"
            },
            {
                "id": 68,
                "transcript": "and here we'll start from zero, then we'll stop at the length of the signal. But here we don't want to just uh have this eye that goes like 123 at each iteration. No, we wanted to jump and we wanted to jump by the, the frame size. So like this third uh like argument here in the range function is the step size in this case. So let's assume the frame size",
                "start_time": "1125.439",
                "end_time": "1151.805"
            },
            {
                "id": 69,
                "transcript": "is equal to 100. So we'll start at the first iteration I is going to be equal to zero, then it's going to be second iteration is going to be equal to 100 then 203 100 you get the idea why do we do that? Well, we do that because in this way, I is always going to be the first sample in a frame. OK?",
                "start_time": "1151.814",
                "end_time": "1177.15"
            },
            {
                "id": 70,
                "transcript": "And that's something that we definitely",
                "start_time": "1178.069",
                "end_time": "1181.29"
            },
            {
                "id": 71,
                "transcript": "need. And so now we could say current frame",
                "start_time": "1182.069",
                "end_time": "1189.78"
            },
            {
                "id": 72,
                "transcript": "unplayed ch",
                "start_time": "1190.56",
                "end_time": "1192.13"
            },
            {
                "id": 73,
                "transcript": "envelope",
                "start_time": "1192.869",
                "end_time": "1193.75"
            },
            {
                "id": 74,
                "transcript": "and they look and so this is equal to the max of the slice of signal that just considers the all the frames in the current, uh all the samples in the current frame. And so this is given by uh the slice of signal calculated between I and I plus",
                "start_time": "1195.959",
                "end_time": "1218.52"
            },
            {
                "id": 75,
                "transcript": "frame size. OK. So we are slicing the signal considering only the samples uh for a given frame.",
                "start_time": "1218.989",
                "end_time": "1228.839"
            },
            {
                "id": 76,
                "transcript": "OK. So, and here we take the um amplitude envelope and we want to append the current frame amplitude envelope. OK.",
                "start_time": "1229.51",
                "end_time": "1243.689"
            },
            {
                "id": 77,
                "transcript": "So we'll do this and here we can uh return the amplitude envelope but we'll return that as a N pi array. So we'll do this. OK. So this should work. But uh let me",
                "start_time": "1244.9",
                "end_time": "1262.829"
            },
            {
                "id": 78,
                "transcript": "just create a constant up here.",
                "start_time": "1265.089",
                "end_time": "1268.63"
            },
            {
                "id": 79,
                "transcript": "So we'll put the frame size equal to 1000 and 24 which is totally legit number for frame size.",
                "start_time": "1269.28",
                "end_time": "1276.589"
            },
            {
                "id": 80,
                "transcript": "OK. So now let's try to calculate the amplitude envelope for the BC signal. And so we'll do a",
                "start_time": "1277.209",
                "end_time": "1288.569"
            },
            {
                "id": 81,
                "transcript": "um pude envelope, we'll pass in the BC signal and we'll pass in the frame size. Now, what I want to do is show you the length of this guy. And obviously, we have an error here, which is NP because I didn't import NP. And so let me import that. So we'll do import NPI as MP.",
                "start_time": "1289.42",
                "end_time": "1314.479"
            },
            {
                "id": 82,
                "transcript": "OK? Now let's go back down here and hopefully this should work. OK? Here we go.",
                "start_time": "1314.839",
                "end_time": "1320.56"
            },
            {
                "id": 83,
                "transcript": "So here we have uh the, the size of this array is 646. So this is the number of frames that we have in the, the BC uh signal. Now, if I change the frame size, uh let's say I have it. So I put it at 512. So now the number of frames should like double or the number of uh like",
                "start_time": "1320.729",
                "end_time": "1347.39"
            },
            {
                "id": 84,
                "transcript": "uh um the, the, the size of the ali envelope also should double, right. Let's see.",
                "start_time": "1347.569",
                "end_time": "1353.109"
            },
            {
                "id": 85,
                "transcript": "Yeah, but I should rerun this and here we go. So we have double the uh the number of frames over here. OK?",
                "start_time": "1353.66",
                "end_time": "1361.43"
            },
            {
                "id": 86,
                "transcript": "Now, this is all good and well, but it only consider the, the case, this amplitude envelope function where we have uh non overlapping frames. If we had uh overlapping uh frames, we would have, we would need to uh change like this um function. And",
                "start_time": "1361.839",
                "end_time": "1383.75"
            },
            {
                "id": 87,
                "transcript": "now if you don't remember what like overlapping and non overlapping frames are, I suggest you to go check out this video to just like refresh or like learn that. But basically, when we have over uh overlapping frames, we'll still have like the, the frame size, which in this case will put equal to 1000 24. But then we have another",
                "start_time": "1383.76",
                "end_time": "1405.68"
            },
            {
                "id": 88,
                "transcript": "um",
                "start_time": "1406.579",
                "end_time": "1407.319"
            },
            {
                "id": 89,
                "transcript": "important like parameter that's called the hop length that tells us. So given like the current frame, how many sample samples we shift to the right for calculating the next frame. And in this case, we'll put 512 which again is a totally legit uh H length.",
                "start_time": "1407.89",
                "end_time": "1427.079"
            },
            {
                "id": 90,
                "transcript": "And here we want to change this function so that it accepts also the a new parameter called hop length. So how do we change this? Well, what the only thing that we need to change here is that instead of like jumping at each iteration by the frame size, we want to jump by the uh hop length, right?",
                "start_time": "1427.43",
                "end_time": "1453.4"
            },
            {
                "id": 91,
                "transcript": "So if we, if we change that now we should have like the whole thing",
                "start_time": "1453.979",
                "end_time": "1459.089"
            },
            {
                "id": 92,
                "transcript": "working. OK. So let's retry this.",
                "start_time": "1459.78",
                "end_time": "1462.989"
            },
            {
                "id": 93,
                "transcript": "OK. So here I'll have to pass the H length, I'll do that And as you can see here, we have 1000 292 samples over here and which uh which is expected because we have a H length of 512",
                "start_time": "1464.01",
                "end_time": "1482.219"
            },
            {
                "id": 94,
                "transcript": "which is like the same like jumping to the right at each frame that we used before when we had the frame size at 512. There's also a nicer way to calculate the amplitude envelope. I mean, the algorithm is the same. It's just like the, the Python code that's a little bit fancier. And I guess they, which showed up to you. OK. So let's call this fancy Ted",
                "start_time": "1483.05",
                "end_time": "1510.52"
            },
            {
                "id": 95,
                "transcript": "envelope and we'll pass in the very same uh parameters over here.",
                "start_time": "1511.13",
                "end_time": "1518.439"
            },
            {
                "id": 96,
                "transcript": "And this is gonna be just a one liner. So we'll do a NP array and here we'll have a list of comprehension and here we'll take the maximum of the signal. Uh Once again, this is gonna be between I and I plus hop uh length.",
                "start_time": "1518.989",
                "end_time": "1540.119"
            },
            {
                "id": 97,
                "transcript": "And then we'll take this for I in",
                "start_time": "1541.03",
                "end_time": "1545.51"
            },
            {
                "id": 98,
                "transcript": "uh well, this is not H length, this is frame size and then we'll take the four I in uh range.",
                "start_time": "1546.14",
                "end_time": "1556.3"
            },
            {
                "id": 99,
                "transcript": "And here is gonna be between zero of the",
                "start_time": "1556.939",
                "end_time": "1562.109"
            },
            {
                "id": 100,
                "transcript": "signal",
                "start_time": "1562.849",
                "end_time": "1564.699"
            },
            {
                "id": 101,
                "transcript": "dot size and the step that we'll use. Now this is the hop length once again",
                "start_time": "1565.31",
                "end_time": "1572.0"
            },
            {
                "id": 102,
                "transcript": "uh up length. OK? So, yep, this should work. OK? So now let me calculate. Uh yeah, let's put it down here. So we'll do fancy, we'll call this Fancy amplitude envelope for the BC. And we'll do a fancy oops fancy",
                "start_time": "1572.589",
                "end_time": "1598.199"
            },
            {
                "id": 103,
                "transcript": "amplitude envelope and we pass in these parameters.",
                "start_time": "1598.739",
                "end_time": "1605.02"
            },
            {
                "id": 104,
                "transcript": "OK.",
                "start_time": "1605.859",
                "end_time": "1606.53"
            },
            {
                "id": 105,
                "transcript": "Here we go attempts to work fine. Now, what we want to show is that the uh",
                "start_time": "1608.369",
                "end_time": "1615.0"
            },
            {
                "id": 106,
                "transcript": "the amplitude envelope calculated with this function, the amplitude envelope function with the fancy amplitude envelope function are the same. So if we're doing that, we could do I A",
                "start_time": "1615.569",
                "end_time": "1627.26"
            },
            {
                "id": 107,
                "transcript": "A E amplitude envelope. Well, let's do this. We'll do a EW PC is equal to fancy a amplitude envelope to PC for all the values.",
                "start_time": "1628.04",
                "end_time": "1643.939"
            },
            {
                "id": 108,
                "transcript": "So let's see if this works. OK. Yeah, that's true. So basically what I've done here is compare",
                "start_time": "1644.489",
                "end_time": "1650.76"
            },
            {
                "id": 109,
                "transcript": "uh like all the items in the array, one by one with the current sponge like item in the other array. And then I, I want like I wanted to have like that all of these values must be equal for all of them. And if that's the case, then we would get a tree which is like what we got. And so basically the two values are the same. In other words, we wrote like the same algorithms like in, in two different versions with Python code.",
                "start_time": "1650.89",
                "end_time": "1679.39"
            },
            {
                "id": 110,
                "transcript": "OK. So this is nice. Now, the final thing that I want to do is to visualize,",
                "start_time": "1679.56",
                "end_time": "1687.819"
            },
            {
                "id": 111,
                "transcript": "I want to visualize the ample envelope for uh all the audio files. OK. So how do we do that? Well, it's quite simple and, and it really relies on the, the code that we've already",
                "start_time": "1689.15",
                "end_time": "1711.589"
            },
            {
                "id": 112,
                "transcript": "uh written",
                "start_time": "1712.209",
                "end_time": "1713.479"
            },
            {
                "id": 113,
                "transcript": "over here for like visualizing like the, the, the wave form. So now the only difference here that we need is to add another plot uh like in each of these like subplots. And so we'll do a plot dot PLT dot uh plot.",
                "start_time": "1714.14",
                "end_time": "1732.939"
            },
            {
                "id": 114,
                "transcript": "Here, we'll do T and here we'll pass the A, the BC and then the color is gonna be equal to red. Now, if you're wondering about this, t uh we haven't defined it and that yet. And so I'll define that in a second. But before doing that, I just want to repeat this",
                "start_time": "1733.28",
                "end_time": "1753.719"
            },
            {
                "id": 115,
                "transcript": "down here for uh red hots",
                "start_time": "1754.26",
                "end_time": "1758.81"
            },
            {
                "id": 116,
                "transcript": "and down here for Duke Ellington.",
                "start_time": "1762.15",
                "end_time": "1767.51"
            },
            {
                "id": 117,
                "transcript": "Oh, let's take this. OK. Now, as you know, as you probably noticed, I haven't defined the amplitude envelope",
                "start_time": "1768.189",
                "end_time": "1778.589"
            },
            {
                "id": 118,
                "transcript": "for the red hots yet. And so we'll do that. We're here and so here I'll do a amplitude envelope and here I'll pass uh red, the red hot uh signal and then the frame size and H length and I'll do the same for Duke",
                "start_time": "1779.319",
                "end_time": "1802.54"
            },
            {
                "id": 119,
                "transcript": "Ellington. Yeah, let me just grab this and pass in here, Duke. OK. This should work. Now, the one thing that it's still missing here that I said is the, this key, right?",
                "start_time": "1802.91",
                "end_time": "1818.81"
            },
            {
                "id": 120,
                "transcript": "OK. So this is basically like the X axis for the plot. And here we have like the Y axis. So, and here we, we want uh time",
                "start_time": "1820.01",
                "end_time": "1830.239"
            },
            {
                "id": 121,
                "transcript": "and so for doing that, what we need to do is first of all get the frames and the frames is gonna be uh equal to a range between a zero and uh the size of the amplitude envelope.",
                "start_time": "1830.819",
                "end_time": "1850.359"
            },
            {
                "id": 122,
                "transcript": "And so this is equal to a WC dot size I could have used also a amplitude envelope uh for like Duke Ellington or red hot chili peppers because it's like the same in terms of like the its length its size. OK. So now I want to calculate tea and here for passing from",
                "start_time": "1850.849",
                "end_time": "1873.55"
            },
            {
                "id": 123,
                "transcript": "frames to time, we can use a, a very nice uh function by lib browser and it's called frames to time over here. And so here",
                "start_time": "1873.77",
                "end_time": "1888.925"
            },
            {
                "id": 124,
                "transcript": "we need to specify the frames and uh we uh need to also specify the, the hop length and the hop length in this case is equal to hop length over here. OK? So here we've basically got the, the time",
                "start_time": "1888.935",
                "end_time": "1910.81"
            },
            {
                "id": 125,
                "transcript": "and uh along with the time we, we've also we also plot the amplitude envelope for um each of the different audio files. OK? So if I haven't made any mistakes, so this should work. Let's see. And here it goes and we have it in red",
                "start_time": "1911.719",
                "end_time": "1931.51"
            },
            {
                "id": 126,
                "transcript": "and yeah, not surprisingly, the amplitude envelope just like full is like the the envelope like of the wave firm. And you can see it here like in red for the BC, for the red hot chili pepper song and for uh Duke Ellington. OK?",
                "start_time": "1931.93",
                "end_time": "1947.29"
            },
            {
                "id": 127,
                "transcript": "So now one thing like that's uh obvious once again, is that like, they usually uh you have like this spikes like in rock music or like popular music more in general, which uh are determined by like the drum kit, like kicking in.",
                "start_time": "1947.579",
                "end_time": "1965.63"
            },
            {
                "id": 128,
                "transcript": "And then, uh usually you also have like the amplitude envelope, the mean amplitude envelope for music that's in a rock genre, pop, popular genre that's usually higher than that for like classical music or jazz music.",
                "start_time": "1965.989",
                "end_time": "1982.75"
            },
            {
                "id": 129,
                "transcript": "OK? But here you have it. I hope like you've enjoyed this video. Now, you know how to create uh a, how to calculate the amplitude envelope, how to visualize waveforms the amplitude envelope and play around with like basic processing features in the browser. So that's all for today.",
                "start_time": "1983.209",
                "end_time": "2004.01"
            },
            {
                "id": 130,
                "transcript": "So if you like the video, please consider like living alike. If you haven't subscribed yet, please consider subscribing if you have any questions, leave them in the comment section below and I guess I'll see you next time. Cheers.",
                "start_time": "2004.16",
                "end_time": "2018.619"
            }
        ]
    }
}